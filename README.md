# Concurrency
Concurrency projects written via Kali Linux subsystem command line. The projects are meant to showcase understanding of parallelism and multithreading. 

These projects were instrumental in shaping my understanding of concurrency and how it is achieved through multithreading. The projects are listed here in order of their completion, Sept - Dec 2024. Each project is matched with an analysis of the output of the programmed deliverable and reflection on the use of different concepts of concurrency.

**Project 1:**

Simulates concurrent drawing of randomly positioned snowmen (three-circle characters) onto a shared image canvas, there are several criteria that must be checked. 
First of all, the snowmen must not overlap each other.
In other words, threads should be aware of the activity of their predecessors as well as those threads running simultaneously.  
The size of the image, the number of operating threads, and the number of snowmen to draw are arguments.
The result is outputimage.png - the result of the threads running.
The project implemented import javax.imageio.ImageIO and java.awt.* API-assisted circle drawing with randomized orientation.
Additionally, the performance of thread behavior is measured and compared. For single and multithreaded, runs were timed and used for performance benchmarking. This is documented inside the DrawingSnowmenConcurrently.pdf.
DrawSnowmenConcurrently.java is the main script, it is in itself the main crux of the project. The project can be altogether accomplished with running this script.
However, additional complexity is added to the project by with bash and python scripts. Therefore, the alternative way of testing the project is to run test.sh. 
Their functionalities are detailed further in the description.
The function of bash and python scripts is optional.
Demonstrates thread-safe collision detection, randomized visual generation, and runtime performance scaling.
Below is a description of the functionalities of each script involved in the creation of this project.

_DrawSnowmenConcurrently.java_
The file containing the java script with multithreading code that generates the output.png image with snowmen and outputs time in milliseconds it takes on an input.
Takes as input w, h, t and n where
⦁	w and h: the width height of the outputimage.png
⦁	t: number of threads for executing
⦁	n: the number of snowmen to draw on the canvas
The output is the outputimage.png with n snowmen randomly generated by t threads
The output is also time in milliseconds to execute file, which is then stored in data.csv file
Compile and run DrawSnowmenConcurrently.java w h t n to test this script alone

Inside the bash_scripts.zip:
_makedata_DrawSnowmen.sh_
Compile and run makedata_DrawSnowmen.sh with optional inputs
Optional inputs are the same as those for the DrawSnowmenConcurrently.java
⦁	Input: w, h, t, n
⦁	t and n are the bound of a randomly selected number between 1 and the t and n values
First the file compiles and runs DrawSnowmenConcurrently.java either with the provided values or the default inputs
These bash scripts compiles and runs DrawSnowmenConcurrently.java with optional inputs
On inputs of 1, 20, 40, 60, 80 and 100 threads drawing 100 snowmen on a 1024 by 1024 canvas size of outputimage.png, producing output of the milliseconds, single and multithreaded, it took for each input to run
The zip folder also contains test.sh, discussed later.

_The expected output in the data.csv is:_
Threads,Single-threaded Time,Multi-threaded Time
1,Time to execute: 21 ms,Time to execute: 19 ms
20,Time to execute: 25 ms,Time to execute: 24 ms
40,Time to execute: 23 ms,Time to execute: 22 ms
60,Time to execute: 26 ms,Time to execute: 27 ms
80,Time to execute: 27 ms,Time to execute: 27 ms
100,Time to execute: 33 ms,Time to execute: 28 ms

_SnowmanPlotdata.py_
Contains a python script that uses matplotlib to generate 2 graphs. 
First graph is structured as number of threads on the x-axis and time on the y-axis. It has values for single and multithreaded runs, as plotted data points in terms of time taken to complete the snowmen drawing task. This graph also has trace lines to distinguish performance, it is graphed in terms of number of threads vs time. 
The second graph represents the number of threads (x-axis) vs speedup (y-axis) from running the program on single to multithreaded mode.
Speedup  = single runtime (ms) /multithreaded runtime (ms)
Running and compiling plotdata.py results in graphs created from data obtained from an input csv.
The sample data input is the data.csv file created by the makedata.sh script.

**An easy way to test run this project is to run test.sh**
Running ./test.sh with optional inputs w and h as width and height of image, and t and n - the number of threads and number of snowmen.
Test will compile and run makedata_DrawSnowmen.sh using either default values or the values provided in the optional input.
Test will compile and run SnowmanPlotdata.py on data.csv.
The result will be 2 graphs showing the performance of threads, and 2 files will be created: outputimage.png with snowmen and a data.csv file.

_DrawingSnowmenConcurrently.pdf_
Contains details regarding different test cases showing the input and the resulting output.

**Project 2:**

This project simulates a dynamic version of the classic Snakes and Ladders board game with a focus on concurrent event processing, data traceability, and real-time state mutation. 
The simulation models a 10x10 grid-based game where three autonomous threads operate in parallel—modifying, observing, and interacting with the game board. 
⦁	PlayerThread: Simulates player movements across a boustrophedon (zig-zag) grid using randomized dice rolls.
⦁	AdderThread: Periodically injects new "snake" or "ladder" transitions into the board, modifying game dynamics.
⦁	RemoverThread: Randomly removes existing transitions to simulate volatile systems.
Each thread logs operations with millisecond-precision timestamps, allowing complete post-run log replay and analytics.
All snakes and ladders respect strict positional constraints (no overlaps, no start/end interference).
Demonstrates validation pipelines and boundary checks relevant to data quality enforcement.
Post-simulation, logs are sorted by timestamp to produce a clear event chronology.
Enables traceability of player decisions and board modifications—analogous to financial audit trails.

_ConcurrentSnakes&Ladders.java_
Compiles and runs on input of k, j and s as stated in the problem statement
⦁	Adder input is k in ms of sleep time
⦁	Remover input is j in ms of sleep time
⦁	Input s is game play time in seconds
⦁	Tested on input for up to 10 seconds of game time with varied thread sleep times from double to triple digits

_ConcurrentSnakes&Ladders.pdf_
Contains details regarding different test cases showing the input and the resulting output.

**Project 3:**

The goal of this project is to implement an efficient parallel algorithm for verifying balanced brackets in a character stream using Java’s ExecutorService thread pooling.
This project explores a concurrent divide-and-conquer strategy, by applying nested matching logic over segments of large bracket strings. It is a simplified contextualization of high-throughput log validation.
The bracket matching problem ensures that every opening bracket ('[') is matched with a  closing bracket (']') with valid nesting. 
The concurrent solution relies on the Thread Pool Executor (newFixedThreadPool) to divide large strings into manageable chunks.
Each thread processes its segment and returns a local triple (b, f, m).
A final merge step recursively combines results to determine global validity. 

_BracketCounter.java_
Runs and compiles as java BracketCounter <n> <t> [seed], where
⦁	n = length of bracket string
⦁	t = number of threads
⦁	seed = optional RNG seed
The script generates a random character array containing '[', ']', and '*' (non-bracket noise).
For every substring of the random character array there is a result produced by the working thread, in the form of (b, f, m), where
⦁	b: a Boolean for "is the substring properly matched?"
⦁	f: final bracket counter (open - close), this should be 0 if properly matched
⦁	m: minimum counter value during traversal (used to detect premature closing brackets)

Given the results of two working threads, (b1, f1,m1) and (b2, f2,m2) from the left and right substring, it is possible to compute the (b, f, m) for the concatenated string where
⦁	b = (b1 ∧ b2) ∨ ((f1 + f2 = 0) ∧ (m1 ≥ 0) ∧ (f1 + m2 ≥ 0))
⦁	f = f1 + f2
⦁	m = min(m1, f1 + m2)

By merging concurrently, matching logic is correctly applied across subarrays.
The output of the script is the execution time (in milliseconds), and two booleans:
⦁	First: Result from parallel algorithm execution (multithreaded)
⦁	Second: Result from the sequential execution (1 thread) and it is used for validation of the parallel execution.

_BracketCounter.pdf_
Contains details regarding different test cases showing the input and the resulting output.

**Project 4:**

The goal of this project is to perform an efficient transformation of a large, sparse 2D matrix into Compressed Sparse Row (CSR) format, written in C, using OpenMP for parallelism.
The first aspect of the project was parallelized generation of a large n x n sparse matrix filled with 0s and 1s using a probability p, where p ∈ {0.05, 0.2, 0.5}.
Then, there is an efficient transformation of the matrix into CSR format.
CSR format is described by:
⦁	values[]: non-zero entries
⦁	cols[]: column indices of non-zero entries
⦁	rowptr[]: offsets marking row start/end
The project is designed to run on serial and parallel execution modes, for the purpose of comparison, to evaluate multithreading efficiency.

_CSR.c_
Compiles and runs as ./csr <n> <p> <s> where
⦁	n: matrix dimension, for an nxn square matrix
⦁	p: probability of a zero (0 ≤ p ≤ 1) in any of the matrix cells.
⦁	s: seed for reproducibility

_The output components are:_ 
⦁	nxn square amtrix generated 
⦁	The CSR arrays: rowptr, cols, values
⦁	Execution time of the transformation phase (with I/Os disabled)

_CSR.pdf_
Contains details regarding different test cases showing the input and the resulting output.

**Project 5:**

This project explores a parallel speculative approach to the regular expression matching problem using Deterministic Finite Automata (DFA) in C with OpenMP. It is designed to improve performance for very large string processing. The approach simulates real-world high-throughput data scanning.
Regular expression matching is usually sequential because each character's effect depends on the previous DFA state. 
However, dividing the input string and processing segments speculatively, enables threads to assume any possible starting state, and pre-processes its segment for all possibilities, producing a state transition map. 
After all segments are processed, the DFA path is reconstructed sequentially.

_Regular_Expression_Matching.c_
Compiles and runs as ./dfa_match <t> <n> where
⦁	t: number of speculative threads (0–4)
⦁	n: length of string (> t)
Thus, as input the program takes a random numeric string (digits 0–9), of size n, divided among t threads.
The first thread proceeds deterministically from the start state.
All other threads process their segments in parallel for each possible starting DFA state, building transition tables.
Final DFA state is computed by composing transitions from all segments.

_The output of the execution is:_
⦁	Print out of the input string
⦁	A boolean determining whether the DFA ends in an accepting state (true/false)
⦁	Time taken to execute in milliseconds (excluding string generation)

_Regular_Expression_Matching.pdf_
Results show speedup vs sequential execution and highlight trade-offs of speculative techniques. 
Execution is averaged across 10 runs per thread configuration (t = 0 to 4).

