# Concurrency
Concurrency projects written via Kali Linux subsystem command line. The projects are meant to showcase understanding of parallelism and multithreading. 
The projects are listed here in order of their completion, Sept - Dec 2024.

**Project 1:**

Simulates concurrent drawing of randomly positioned snowmen (three-circle characters) onto a shared image canvas, there are several criteria that must be checked. 
First of all, the snowmen must not overlap each other.
In other words, threads should be aware of the activity of their predecessors as well as those threads running simultaneously.  
The size of the image, the number of operating threads, and the number of snowmen to draw are arguments.
The result is outputimage.png - the result of the threads running.
The project implemented import javax.imageio.ImageIO and java.awt.* API-assisted circle drawing with randomized orientation.
Additionally, the performance of thread behavior is measured and compared. For single and multithreaded, runs were timed and used for performance benchmarking. This is documented inside the DrawingSnowmenConcurrently.pdf.
DrawSnowmenConcurrently.java is the main script, it is in itself the main crux of the project. The project can be altogether accomplished with running this script.
However, additional complexity is added to the project by with bash and python scripts. Therefore, the alternative way of testing the project is to run test.sh. 

DrawSnowmenConcurrently.java
The file containing the java script with multithreading code that generates the output.png image with snowmen and outputs time in milliseconds it takes on an input.
Takes as input w, h, t and n where
	w and h: the width height of the outputimage.png
	t: number of threads for executing
	n: the number of snowmen to draw on the canvas
The output is the outputimage.png with n snowmen randomly generated by t threads
The output is also time in milliseconds to execute file, which is then stored in data.csv file
Compile and run DrawSnowmenConcurrently.java w h t n to test this script alone

bash_scripts.zip (makedata_DrawSnowmen.sh and test.sh)
makedata_DrawSnowmen.sh
Compile and run makedata_DrawSnowmen.sh with optional inputs
Optional inputs are the same as those for the DrawSnowmenConcurrently.java
t and n are the bound of a randomly selected number between 1 and the t and n values
First the file compiles and runs DrawSnowmenConcurrently.java either with the provided values or the default inputs

SnowmanPlotdata.py
Contains a python script that uses matplotlib to generate 2 graphs. 
First graph is structured as number of threads on the x-axis and time on the y-axis. It has values for single and multithreaded runs. 
The second graph represents the number of threads (x-axis) vs speedup (y-axis) from running the program on single to multithreaded mode.
(Speedup  = single runtime (ms) /multithreaded runtime (ms))

An easy way to test run this project is to run test.sh
Running ./test.sh with optional inputs w and h as width and height of image, and t and n - the number of threads and number of snowmen.
Test will compile and run makedata_DrawSnowmen.sh using either default values or the values provided in the optional input.
Test will compile and run SnowmanPlotdata.py on data.csv.
The result will be 2 graphs showing the performance of threads, and 2 files will be created: outputimage.png with snowmen and a data.csv file.

DrawingSnowmenConcurrently.pdf
Contains details regarding different test cases showing the input and the resulting output.

Project 2:

This project simulates a dynamic version of the classic Snakes and Ladders board game with a focus on concurrent event processing, data traceability, and real-time state mutation. 
The simulation models a 10x10 grid-based game where three autonomous threads operate in parallel—modifying, observing, and interacting with the game board. 
⦁	PlayerThread: Simulates player movements across a boustrophedon (zig-zag) grid using randomized dice rolls.
⦁	AdderThread: Periodically injects new "snake" or "ladder" transitions into the board, modifying game dynamics.
⦁	RemoverThread: Randomly removes existing transitions to simulate volatile systems.
Each thread logs operations with millisecond-precision timestamps, allowing complete post-run log replay and analytics.

ConcurrentSnakes&Ladders.java
Compiles and runs on input of k, j and s as stated in the problem statement
⦁	Adder input is k in ms of sleep time
⦁	Remover input is j in ms of sleep time
⦁	Input s is game play time in seconds
⦁	Tested on input for up to 10 seconds of game time with varied thread sleep times from double to triple digits

ConcurrentSnakes&Ladders.pdf
Contains details regarding different test cases showing the input and the resulting output.

Project 3:

The goal of this project is to implement an efficient parallel algorithm for verifying balanced brackets in a character stream using Java’s ExecutorService thread pooling.
This project explores a concurrent divide-and-conquer strategy, by applying nested matching logic over segments of large bracket strings. It is a simplified contextualization of high-throughput log validation.
The bracket matching problem ensures that every opening bracket ('[') is matched with a  closing bracket (']') with valid nesting. 
The concurrent solution relies on the Thread Pool Executor (newFixedThreadPool) to divide large strings into manageable chunks.
Each thread processes its segment and returns a local triple (b, f, m).
A final merge step recursively combines results to determine global validity. 

BracketCounter.java
Runs and compiles as java BracketCounter <n> <t> [seed], where
⦁	n = length of bracket string
⦁	t = number of threads
⦁	seed = optional RNG seed
The script generates a random character array containing '[', ']', and '*' (non-bracket noise).
For every substring of the random character array there is a result produced by the working thread, in the form of (b, f, m), where
⦁	b: a Boolean for "is the substring properly matched?"
⦁	f: final bracket counter (open - close), this should be 0 if properly matched
⦁	m: minimum counter value during traversal (used to detect premature closing brackets)

Given the results of two working threads, (b1, f1,m1) and (b2, f2,m2) from the left and right substring, it is possible to compute the (b, f, m) for the concatenated string where
⦁	b = (b1 ∧ b2) ∨ ((f1 + f2 = 0) ∧ (m1 ≥ 0) ∧ (f1 + m2 ≥ 0))
⦁	f = f1 + f2
⦁	m = min(m1, f1 + m2)

By merging concurrently, matching logic is correctly applied across subarrays.
The output of the script is the execution time (in milliseconds), and two booleans:
⦁	First: Result from parallel algorithm execution (multithreaded)
⦁	Second: Result from the sequential execution (1 thread) and it is used for validation of the parallel execution.
⦁ See BracketCounter.pdf for details


**Project 4:**
The goal of this project is to perform an efficient transformation of a large, sparse 2D matrix into Compressed Sparse Row (CSR) format, written in C, using OpenMP for parallelism.
The first aspect of the project was parallelized generation of a large n x n sparse matrix filled with 0s and 1s using a probability p, where p ∈ {0.05, 0.2, 0.5}.
Then, there is an efficient transformation of the matrix into CSR format.
CSR format is described by:
⦁	values[]: non-zero entries
⦁	cols[]: column indices of non-zero entries
⦁	rowptr[]: offsets marking row start/end

CSR.c
Compiles and runs as ./csr <n> <p> <s> where
⦁	n: matrix dimension, for an nxn square matrix
⦁	p: probability of a zero (0 ≤ p ≤ 1) in any of the matrix cells.
⦁	s: seed for reproducibility

The output components are: 
⦁	nxn square amtrix generated 
⦁	The CSR arrays: rowptr, cols, values
⦁	Execution time of the transformation phase (with I/Os disabled)
⦁ See CSR.pdf for details

**Project 5:**
This project explores a parallel speculative approach to the regular expression matching problem using Deterministic Finite Automata (DFA) in C with OpenMP. It is designed to improve performance for very large string processing. The approach simulates real-world high-throughput data scanning.
Regular expression matching is usually sequential because each character's effect depends on the previous DFA state. 
However, dividing the input string and processing segments speculatively, enables threads to assume any possible starting state, and pre-processes its segment for all possibilities, producing a state transition map. 
After all segments are processed, the DFA path is reconstructed sequentially.

Regular_Expression_Matching.c
Compiles and runs as ./dfa_match <t> <n> where
⦁	t: number of speculative threads (0–4)
⦁	n: length of string (> t)
Thus, as input the program takes a random numeric string (digits 0–9), of size n, divided among t threads.
The first thread proceeds deterministically from the start state.
All other threads process their segments in parallel for each possible starting DFA state, building transition tables.
Final DFA state is computed by composing transitions from all segments.

The output of the execution is:
⦁	Print out of the input string
⦁	A boolean determining whether the DFA ends in an accepting state (true/false)
⦁	Time taken to execute in milliseconds (excluding string generation
⦁	See Regular_Expression_Matching.pdf for details


